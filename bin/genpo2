#!/usr/bin/perl -CSDAL
use warnings;
use strict;
use utf8;
use File::Basename qw(basename);
use Cwd qw(abs_path);
use File::Copy qw(copy);
use File::Find::Rule;
use File::Slurp::Unicode;
use File::Path qw(mkpath rmtree);
use File::Temp qw(tempfile);
use Getopt::Long qw(:config bundling no_ignore_case permute no_getopt_compat);
use IPC::Run qw(run);
use List::MoreUtils qw(uniq);

my $dir;
my $po_name; # probably his name is Wario
my $lang = "de"; # TODO

sub fix_headers($)
{
  my ($pot) = @_;

  $pot =~ s/^"Report-Msgid-Bugs-To:.*\n//m;
  $pot =~ s/^"POT-Creation-Date:.*\n//m;
  $pot =~ s/^"Language-Team: .*\n//m;
  $pot =~ s/^"Last-Translator: .*\n//m;
  $pot =~ s/^"PO-Revision-Date:.*\n//m;
  $pot =~ s/(?<=^"Content-Type: text\/plain; charset=)CHARSET/UTF-8/m;
  my $pkg = $po_name;
  my $uc_pkg = uc($pkg);
  $pot =~ s/SOME DESCRIPTIVE TITLE/TRANSLATION CATALOG OF $uc_pkg/;
  my $year = 1900 + (localtime)[5];
  $pot =~ s/YEAR IServ GmbH/$year IServ GmbH/;
  $pot =~ s/# FIRST AUTHOR <EMAIL\@ADDRESS>, YEAR\./# IServ GmbH <info\@iserv.eu>, $year./;
  $pot =~ s/PACKAGE/$pkg/;
  $pot =~ s/CHARSET/UTF-8/;
  $pot =~ s{#: /tmp/twig2php-[^/]+/}{#: }g;

  $pot;
}

sub get_po_name($)
{
  my ($dir) = @_;
  if (-f "$dir/debian/control")
  {
    my $pkg = (qx(cd $dir && dh_listpackages | head -n 1) =~ s/^iserv-//gr);
    $pkg =~ s/^iserv3-(.+)/${1}3/g;
    chomp $pkg;
    return $pkg if length $pkg;
  }
  elsif (-f "$dir/composer.json")
  {
    my $pkg = ((qx(cd $dir && jq -r '.name' composer.json) =~ s{^(iserv-|iserv/)}{}gr) =~ s{/}{-}gr);
    chomp $pkg;
    return $pkg if length $pkg;
  }

  return basename($dir);
}


my $help_exit = 0;
my %opt;
GetOptions(\%opt,
  "list-processed-files|f",
  "help|h",
  "root-dir|r=s",
  "list|l",
  "only-pot|t"
) or do { $opt{help} = 1; $help_exit = 1; };

print STDERR <<USAGE and exit $help_exit if $opt{help} or @ARGV != 1;
Usage: genpo dir
Options
 -f, --list-processed-files	only list all processed files
 -h, --help                	show this help
 -l, --list                	list pot files and po files (last only when not using -t) to be
                           	generated
 -r, --root-dir            	root directory for extracting translations (default: locale)
 -t, --only-pot            	do not check and update po file, only maintain pot file
USAGE

my $root_dir = $opt{"root-dir"} // "locale";

($dir) = @ARGV;
$dir = abs_path $dir;
$po_name = get_po_name($dir);

my $err;

my @exclude = qw(debian .git*);

my $header =
  "msgid \"\"\n".
  "msgstr \"\"\n".
  "\"MIME-Version: 1.0\\n\"\n".
  "\"Content-Type: text/plain; charset=UTF-8\\n\"\n".
  "\"Content-Transfer-Encoding: 8bit\\n\"\n".
  "\"Plural-Forms: nplurals=2; plural=n != 1;\\n\"\n";

my @xgettext = (
  qw(xgettext),
  "--copyright-holder=IServ GmbH",
  "--package-name=" . $po_name,
  qw(--from-code=utf-8 --add-location=file --sort-output -j)
);

my %process_cmd = (
  "php3" => [
    @xgettext,
    "--language", "PHP",
    "-k__:1",
    "-k__n:1,2",
    "-k__np:1c,2,3",
    "-k__p:1c,2",
    "-k_n:1,2",
    "-k_np:1c,2,3",
    "-k_p:1c,2",
    "-knpgettext:1c,2,3",
    "-kpgettext:1c,2",
    "-o",
  ],
  "js" => [
    @xgettext,
    "--language", "JavaScript",
    "-k_",
    "-k__",
    "-k__p:1c,2",
    "-k_p:1c,2",
    "-o",
  ],
  "php2" => [
    @xgettext,
    "--language", "PHP",
    "-k_c",
    "-k_date",
    "-o",
  ],
  "perl" => [
    @xgettext,
    "--language", "Perl",
    "-k_",
    "-o",
  ],
  "shell" => [
    @xgettext,
    "--language", "Shell",
    "-o",
  ],
  "pot" => [
    "msgcat", "--add-location=file", "--sort-output",
  ],
);

my $twig2php_out = "/tmp/twig2php-" . basename abs_path $dir;
my $vue2pot_out = "/tmp/vue2pot-" . basename abs_path $dir;

my %convert_cmd = (
  "twig" => ["twig2php", "-o", $twig2php_out],
  "vue" => ["js-gettext-extract", "--output", $vue2pot_out],
);

my %convert_target = (
  "twig" => ["backend", "php3"],
  "vue" => ["frontend", "pot"],
);

my %convert_out = (
  "twig" => $twig2php_out,
  "vue" => $vue2pot_out,
);

# magic
sub new_rule() { File::Find::Rule->new };
chdir $dir or die "failed to chdir\n";
my @files =
  new_rule->or(
    new_rule->maxdepth(0)->name(@exclude)->prune->discard,
    new_rule,
  )->file->in(".");

my (%add, %process, %fn_out, %content, %convert);
for my $fn (@files)
{
  my $content = read_file $fn unless $opt{"list-processed-files"};
  if ($fn eq "www/inc/locale.inc" or $fn =~ m{(?:(?:^|/)(?:var/cache|node_modules|vendor|public/static|public/bundles)/|/polyfill\.min\.js$)})
  {
    # skip
  }
  elsif ($opt{"list-processed-files"})
  {
    next if $fn =~ m{^\Q$root_dir/\E};
    print "$fn\n";
    next;
  }
  elsif ($fn =~ m{^\Q$root_dir\E/.+\.po$})
  {
    # po
    my $target = $fn =~ q{-js\.po$}? "frontend": "backend";
    die "ambigououououose po for $target!!!\n" if defined $fn_out{$target};
    $fn_out{$target} = $fn;
    $content{$target} = $content;
  }
  elsif ($fn =~ q{^priv/})
  {
    # priv
    for ($content =~ /^(?:module|title|description)\s+(.+)/mg)
    {
      push @{$add{backend}{$_}}, $fn;
    }
  }
  elsif ($fn =~ q{^config/})
  {
    # iservcfg
    for ($content =~ /^(?:name|description|group)\s+(.+)/mg)
    {
      push @{$add{backend}{$_}}, $fn;
    }
    for (map { split /\|/, $_ } $content =~ /^type\s+select\[(.+)\]/mg)
    {
      s/.*=//;
      push @{$add{backend}{$_}}, $fn;
    }
  }
  elsif ($fn =~ /\.(php|inc|mod)$/ or $content =~ /^#![\w\/]+php/s)
  {
    push @{$process{backend}{$fn =~ /^www/? "php2": "php3"}}, $fn;
  }
  elsif ($fn =~ /\.js$/)
  {
    push @{$process{frontend}{js}}, $fn;
  }
  elsif ($fn =~ /\.pm$/ or $content =~ /^#![\w\/]+perl/s)
  {
    push @{$process{backend}{perl}}, $fn;
  }
  elsif ($fn =~ /\.(sh|templ)$/ or $content =~ /^#!\/bin\/(sh|bash)/s)
  {
    push @{$process{backend}{shell}}, $fn;
  }
  elsif ($fn =~ /\.(twig|vue)$/)
  {
    -d $convert_target{$1} ? rmtree $convert_target{$1} : unlink $convert_target{$1};
    push @{$convert{$1}}, $fn;
  }
}

exit if $opt{"list-processed-files"};

for my $type (sort keys %convert)
{
  my @convert_run;
  push @convert_run, @{$convert_cmd{$type}};
  push @convert_run, @{$convert{$type}};
  run \@convert_run, ">", \my $throw_it_away or die "covert for type $type failed: @convert_run\n";

  my @converted_files;

  if (-d $convert_out{$type})
  {
    @converted_files = new_rule->file->in($convert_out{$type});
  }
  else
  {
    push @converted_files, $convert_out{$type};
  }

  push @{$process{$convert_target{$type}[0]}{$convert_target{$type}[1]}}, @converted_files;
}

for my $target (qw(backend frontend))
{
  next if not $add{$target} and not $process{$target};
  $fn_out{$target} = "$root_dir/$lang/" . $po_name .
      ($target eq "frontend" ? "-js" : "") . ".po" unless $fn_out{$target};
  my $fn_out = $fn_out{$target};
  my $pot = $header;

  for my $msgid (sort keys %{$add{$target}})
  {
    my @fn = uniq sort @{$add{$target}{$msgid}};
    $msgid =~ s/["\\]/\\$&/g;
    $pot .= "\n";
    $pot .= "#: $_\n" for @fn;
    $pot .= "msgid \"$msgid\"\n";
    $pot .= "msgstr \"\"\n";
  }

  my ($fn_tmp, $old_fn_tmp);
  if ($process{$target})
  {
    (undef, $fn_tmp) = tempfile("/tmp/genpo.XXXXXXXX");

    write_file $fn_tmp, $pot;
    for my $source_lang (sort keys %{$process{$target}})
    {
      my @cmd = (@{$process_cmd{$source_lang}},
          $fn_tmp, @{$process{$target}{$source_lang}});
      # merge (generated) pot templates (e.g. converted vue files) to the main
      # pot file
      if ($source_lang eq "pot")
      {
        my (undef, $new_fn_tmp) = tempfile("/tmp/genpo.XXXXXXXX");
        push @cmd, ("-o", $new_fn_tmp);
        $old_fn_tmp = $fn_tmp;
        $fn_tmp = $new_fn_tmp;
      }

      run \@cmd or die "xgettext failed: @cmd\n";
      do { unlink $old_fn_tmp; undef $old_fn_tmp; } if defined $old_fn_tmp;
    }
    $pot = read_file $fn_tmp;
    if ($pot eq $header)
    {
      unlink $fn_tmp;
    }
    else
    {
      $pot = fix_headers $pot;
    }
  }

  next if $pot eq $header;

  die "no po found for $target\n" if not defined $fn_out;

  my $fn_pot = "$dir/$root_dir/templates/" . basename $fn_out =~ s/\.po$/.pot/gr;
  if ($opt{list})
  {
    my ($out) = "$fn_pot\n" =~ s{^\Q$dir\E/}{}gr;
    print $out;
  }
  else
  {
    mkpath "$dir/$root_dir";
    mkpath "$dir/$root_dir/templates";
    if (defined $fn_tmp)
    {
      copy $fn_tmp, $fn_pot;
      unlink $fn_tmp ;
      my $pot = read_file $fn_pot;
      $pot = fix_headers $pot;
      write_file $fn_pot, $pot;
    }
    else
    {
      $pot = fix_headers $pot;
      # write pot if don't head anything to process and just must add "added" values
      # like config
      write_file $fn_pot, $pot;
    }
  }

  unless ($opt{"only-pot"})
  {
    if ($opt{list})
    {
      my ($out) = "$fn_out\n" =~ s{^\Q$dir\E/}{}gr;
      print $out;
    }
    else
    {
      # prepend header if missing
      my $current = read_file $fn_out;
      $current = $header . "\n" . $current unless $current =~ /"Content-Type: (.+)"/;
      write_file $fn_out, $current;

      run [ qw(msgmerge -q -U -N --backup=none), $fn_out, "-" ],
           "<", \$pot or die "msgmerge failed\n";
      my $new = read_file $fn_out;

      printf "%s updated\n", $fn_out if $new ne $content{$target};

      $new =~ s/"\n\s*"//g; # ZeilenumbrÃ¼che entfernen
      my @missing = $new =~ /^msgid(?:_plural)? "(.+)"\nmsgstr ""\n/mg;
      my @unused = $new =~ /^#~ msgid(?:_plural)? "(.+)"\n/mg;

      print sort map "$fn_out missing: $_\n", @missing if @missing;
      print sort map "$fn_out unused: $_\n", @unused if @unused;

      $err += @missing;
      $err += @unused;
    }
  }
}

exit !!$err;
